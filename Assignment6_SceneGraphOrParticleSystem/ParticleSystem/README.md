# Assignment 6 - Particle System

*TODO*: Please edit the following information in your assignment

* Name and partners name(At most 1 partner for this Assignment): 
* How many hours did it take you to complete this Assignment? 
* Did you collaborate or share ideas with any other students/TAs/Professors? 
* Did you use any external resources? 
  * (tbd if any)
  * (tbd if any)
  * (tbd if any)
* (Optional) What was the most interesting part of the assignment? How would you improve this assignment?
  
## Description

In previous lectures and labs, we learned that a single model might be
used multiple times without increasing the memory load on either the
CPU or GPU.  Additionally, we learned that we can abstract not just
geometry, but lighting and shading as well.  However, we have yet to
put some of these techniques into practice.

A particle system is a technique in which an Emitter is created to
place instances of an object or model in a scene and set up their
initial parameters (things like velocity, lifespan, etc).  Each of
these Particles will be changed as the scene is animated: They may be
scaled to reduce size with every frame, they may rotate as the move in
the scene, or change transparency.  Once a particle is at the end of
its lifespan, it is destroyed and no longer rendered.

In this assignment, we are creating a fountain of models.  The Emitter
is to be placed at the origin.  Each Particle will be an instance of
geometry read in by your existing OBJ readers.  This means that
instead of a fountain of water, we will be creating a fountain of
bunnies, or houses, or monkeys, etc.  Particles should be emitted with
an initial velocity that is generally up (0,1,0), but I encourage you
to put some random numbers in the x and y components -- it's a
fountain, not a hose!  Each particle should be scaled to your liking
and have a lifespan measured in seconds, again, to your liking.  When
the lifespan is reached, the object should be destroyed and no longer
rendered.

Each Particle in our system should **NOT** contain its own copy of
geometry from the model.  Instead, it should use a pointer to the
model to facilitate rendering after modifying its position/scale/etc.
Remember in Lab 8 we introduced a Renderable class that can be drawn
with unique transforms!  Keep in mind that the velocity might start
out as pointing up, but should be acted upon by gravity (0, -1, 0) as
in a general simulation.  This will mean that the particles will go
up, and then come back down as appropriate.
  
### Assignment Strategy

In order to get started with this assignment, I recommend reading
about Particle Systems [here]
(https://cesium.com/docs/tutorials/particle-systems/).  This is a pretty good tutorial on general particle systems.
  
## Emitters and Particles

The primary object that will be placed in the scene will be an
Emitter.  The emitter can (and likely should) be its own class that
might look something like this:

```cpp
class Emitter {
protected:
  QVector<Particle> particles_;
  QVector3D position_;
  QVector3D orientation_;
  unsigned int particlesPerSecond_;
  Renderable* particleModel_;
  
public:
  Emitter(const QVector3D& position, const QVector3D& orientation, unsigned int pps, Renderable* particleModel);

  void update(unsigned int msSinceLastFrame) {
    // First, loop through all particles and update/draw them
	// Then, determine how many particles must be emitted
	// Then emit them one at a time.
	// Then, clean up our particle vector by removing dead particles
	
  }
  void emitParticle();
};
```

Particles are always generated by an emitter and (mostly) manage
themselves.  A Particle class might look something like:

```cpp
class Particle {
protected:
  Renderable* modelToRender_;
  QMatrix4x4 particleTransform_;
  QVector3D velocity_;
  float secondsLeftToLive_;

public:
  Particle(Renderable* model, const QVector3D& velocity, float lifespan);

  void updateAndDraw(unsigned int msSinceLastFrame);
  bool isDead() const {return secondsLeftToLive_ > 0.0;}
};
```

## Task 2 - Why is our system efficient?

In a few sentences why is our approach of keeping a pointer to the
geometry to be drawn an optimization? Note: You can learn more about [instancing](https://learnopengl.com/Advanced-OpenGL/Instancing).
  
**Answer here**: *Your answer here*
  
## How to run your program

Your solution should compile using the standard CMake build procedure. 

Your program should then run by typing in: `./lab`  


## Deliverables

- A solar system with at least 3 planets and 6 moons.
- Edit the readme to answer Task 2

* You need to commit your code to this repository.

### Rubric

<table>
  <tbody>
    <tr>
      <th>Points</th>
      <th align="center">Description</th>
    </tr>
    <tr>
      <td>30% (Core)</td>
	    <td align="left"> <ul><li>Is the code clearly documented?</li> <li>Are there no memory leaks?</li> <li>Did you make sure your code worked with the 'build.py' or did we have a headache compiling your code?</li></ul></td>
    </tr>   
    <tr>
      <td>60% (Core)</td>
	    <td align="left"><ul><li>(60%) Does the scene properly render. That is, do models get created, manipulated, and then disappear.</li></ul></td>
	</tr>
    <tr>
      <td>10% (Advanced)</td>
      <td align="left"><ul><li>(10%) Did you answer why our system strategy is often better than a naieve approach?</li></ul></td>
	</tr>	
  </tbody>
</table>


## More Resources

Links on Scenegraphs
* (**KEY resource**) [Read this tutorial](./media/SceneGraphs.pdf)
* Nice slideshow on scene graphs: https://www.cs.utexas.edu/users/fussell/courses/cs354/lectures/lecture13.pdf
* https://www.panda3d.org/manual/index.php/The_Scene_Graph
* http://www.realityprime.com/blog/2007/06/scenegraphs-past-present-and-future/
* http://what-when-how.com/advanced-methods-in-computer-graphics/scene-graphs-advanced-methods-in-computer-graphics-part-3/
* https://en.wikipedia.org/wiki/Tree_traversal

## Going Further

* Try drawing other models or points to play with color, scale, and transparency* Try implementing transparency and depth sorting

